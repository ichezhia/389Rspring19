# Writeup 4 - Operational Security and Social Engineering

Name: Iniyan Chezhian
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examniation.

Digital acknowledgement: Iniyan Chezhian

## Assignment Writeup

### Part 1 (40 pts)

I first started with the given code, so I did:

    nc 1337bank.money 1337

This gave me a prompt:

    Give me a domain or IP to look up:

So this is the server asking for something to presumable run on its command line. I tried to give it its own IP address and website, but this did nothing.

I searched online on how to do command line injection, and you can use ; or & or && to precede your command to run it as another command and ignore the first command. I entered:

    ; ls

This seemed to work, as it gave me a folder list.

Now I tried:

    ; bash

This let me freely have my own shell right there and I could do whatever I wanted in that shell. I played around for a bit.

Then to find the flag, I did:

    find . -name '*.txt'

This showed me that the file was in .home/flag.txt

    cd home

    less flag.txt

`less` didn't work. So I tried another file viewer, so I did:

    cat flag.txt

Then I got the flag:
>CMSC389R-{d1gging_f0r_flag5_thr0ugh_1njec7ion}

To prevent command line injection, v0idcache could add input validation for what people can enter. So it would first check the input and not run the command if it contains these characters:

````> & |  ; $ > < ` \ !````

Another way would be to use a whitelist regex so that it would only accept 1-20 letters and numbers characters:

    ^[a-z0-9]{1,20}$

_Source: https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.md_

### Part 2 (60 pts)

Starting with the stub code, I played around with a socket.send for a while. I really wanted to just send "; bash". This would make it really easy for me to have my own "shell". However, it seemed that the socket wasn't interactive. Therefore, I had to send the commands one by one.

One problem I thought about while planning was that a command on 1337bank.money:1337 would always be sent to the root at /. When the user does cd into a directory, I needed a way to keep track of this. Therefore, I added a directory string to keep track of the current directory. I will just do a ; cd {directory}; {next command}

I worked on creating the code. Looking online, the best way was to make an infinite loop with while True. Then use input() to get the user's input. I had some issues with input() so I switched to raw_input(), which uses strings instead of strings and variables. The rest was creating if cases and socket.send() for all possible commands. My implemented shell cannot do everything, but it can do everything in the public test screenshot. I have added my own screenshot showing the same ability.

I had some trouble with the code going to fast and not waiting for the server. It seemed that having a print statement before socket.send() seemed to help. I made it a little fancy by saying ".....injecting {command}". This shows the user the exact command injection being performed. I also added some style by instead of using a > prompt, I did 1337bank.money:~{current directory}$ . This makes the user more comfortable using this shell, as it looks like a normal shell like bash, etc.

So basic shell works, help works, and quit works. I was not able to get pull working. I tried to get it working by using bash and cp. However, this wasn't working. Another possible way would be to just cat the file then save the string to the specified file. But, this didn't seem the correct intuitive way to do it, and would only work for text files.

The stub.py file and a screenshot of the shell working are in this writeup folder.
